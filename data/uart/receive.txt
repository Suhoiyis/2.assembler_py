# t0 UART 基地址 (0x30000000)
# t1 临时状态值
# s1 数据缓冲区指针 (指向存放数据的内存地址)
# a0 存放刚接收的数据
# a7 计数器

# 初始化
lui   t0, 0x30000       # t0 = 0x30000000 (UART 基地址)
addi  t1, zero, 3       # t1 = 3 (二进制...0011)
sw    t1, 0(t0)         # 将 3 写入 0x30000000 (UART_CTRL)
                        # 使能第0位(发送)和第1位(接收)

# (设置数据缓冲区指针 s1, 假设存在 0x10000007)
lui   s1, 0x10000       # s1 = 0x10000000
addi  s1, s1, 7       # s1 = 0x10000007 (s1 现在是数据指针)
addi  a7, zero, 3       # 初始化计数器 a7 = 3 (接收3个数据)

# 外循环 (数据循环)
rx_loop_start:
    beq   a7, zero, rx_loop_end # 如果计数器为0, 说明3个都收完了, 跳转到结尾

# 内层循环 等待
wait_rx:
    lw    t1, 4(t0)         # 从地址 tO+4（Ox30000004）加载 UART_STATUS 的值到 t1
    andi  t1, t1, 2         # 按位与，，仅保留 t1的第1位（接收完成标志位，1表示接收完成，0表示正在接收）（2的二进制是000010）其他位归零
    beq   t1, zero, wait_rx # t1 等于θ（即接收未完成），则跳转回 wait_rx 继续等

# 接收
lw    a0, 16(t0)        # 从地址 t0+16（0x30000010），即 UART_RXDATA，读取数据到 aθ

# 存储数据并更新外循环
    sb    a0, 0(s1)         # 将 a0 中的数据（一个字节？）存入 s1 指向的内存
    addi  s1, s1, 1         # 缓冲区指针 s1 指向下一个空位
    addi  a7, a7, -1        # 计数器 a7 减 1
    jal   zero, rx_loop_start # 无条件跳回外层循环的起点, 接收下一个

rx_loop_end:
    # (3个数据接收完毕, 存储在 0x10000007, 8, 9 三个地址中)