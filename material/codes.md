### RISC-V 指令格式规范


| **R-type** | `31-25`                        | `24-20`     | `19-15`     | `14-12`        | `11-7`     | `6-0`          |
| ---------- | ------------------------------ | ----------- | ----------- | -------------- | ---------- | -------------- |
|            | funct7（7bit）                  | rs2（5bit） | rs1（5bit）  | funct3（3bit）  | rd（5bit）  | opcode（7bit） |


| **I-type** | `31-20`            | `19-15`     | `14-12`        | `11-7`     | `6-0`          |
| ---------- | ------------------ | ----------- | -------------- | ---------- | -------------- |
|            | imm[11:0]（12bit）  | rs1（5bit） | funct3（3bit）  | rd（5bit）  | opcode（7bit）  |

| **S-type** | `31-25`           | `24-20`     | `19-15`     | `14-12`        | `11-7`           | `6-0`          |
| ---------- | ----------------- | ----------- | ----------- | -------------- | ---------------- | -------------- |
|            | imm[11:5]（7bit）  | rs2（5bit） | rs1（5bit）  | funct3（3bit）  | imm[4:0]（5bit） | opcode（7bit）  |

| **B-type** | `31`    | `30-25`   | `24-20`     | `19-15`     | `14-12`        | `11-8`   | `7`     | `6-0`          |
| ---------- | ------- | --------- | ----------- | ----------- | -------------- | -------- | ------- | -------------- |
|            | imm[12] | imm[10:5] | rs2（5bit）  | rs1（5bit） | funct3（3bit）  | imm[4:1] | imm[11] | opcode（7bit ） |

| **U-type** | `31-12`             | `11-7`     | `6-0`        |
| ---------- | ------------------- | ---------- | ------------ |
|            | imm[31:12]（20bit） | rd（5bit） | opcode（7bit） |

| **J-type** | `31`    | `30-21`   | `20`    | `19-12`    | `11-7`     | `6-0`        |
| ---------- | ------- | --------- | ------- | ---------- | ---------- | ------------ |
|            | imm[20] | imm[10:1] | imm[11] | imm[19:12] | rd（5bit） | opcode（7bit ） |



opcode(操作码)：指令的基本操作，这个缩写是它惯用名称。
rd：目的操作寄存器，用来存放操作结果。
funct3：一个另外的操作码字段。
rs1：第一个源操作数寄存器。
rs2：第二个源操作数寄存器。
funct7：一个另外的操作码字段。
imm：立即数


#### 立即数拼接规则：
- **S-type**：`imm = {imm[11:5], imm[4:0]}`
- **B-type**：`imm = {imm[12], imm[11], imm[10:5], imm[4:1], imm[0]}`
- **J-type**：`imm = {imm[20], imm[19:12], imm[11], imm[10:1], imm[0]}`

需要特别注意：
1. 所有立即数字段都采用符号扩展
2. B-type 和 J-type 的立即数最低位恒为 0（按 2 字节对齐）
3. 字段位序按大端排列（高位在前）

### R型指令
R型指令包括加法、减法、逻辑运算、移位运算等。
| `31-25`   | `24-20`    | `19-15` | `14-12`    | `11-7` | `6-0`      | R-Type       |
| ------------ | --------| ------- | ---------- | ------ | ---------- | ------------ |
| `funct7 `    | rs2     | rs1     | funct3     | rd     | opcode     |  指令名称     |
| `0000000`    | rs2     | rs1     | `000`      | rd     | `0110011`  | R_add        |
| `0100000`    | rs2     | rs1     | `000`      | rd     | `0110011`  | R_sub        |
| `0000000`    | rs2     | rs1     | `001`      | rd     | `0110011`  | R_sll        |
| `0000000`    | rs2     | rs1     | `010`      | rd     | `0110011`  | R_slt        |
| `0000000`    | rs2     | rs1     | `011`      | rd     | `0110011`  | R_sltu       |
| `0000000`    | rs2     | rs1     | `100`      | rd     | `0110011`  | R_xor        |
| `0000000`    | rs2     | rs1     | `101`      | rd     | `0110011`  | R_srl        |
| `0100000`    | rs2     | rs1     | `101`      | rd     | `0110011`  | R_sra        |
| `0000000`    | rs2     | rs1     | `110`      | rd     | `0110011`  | R_or         |
| `0000000`    | rs2     | rs1     | `111`      | rd     | `0110011`  | R_and        |


ADD rd, rs1, rs2: 将寄存器rs1和rs2中的值相加，结果存储在rd。
SUB rd, rs1, rs2: 从寄存器rs1中减去寄存器rs2的值，结果存储在rd。
AND rd, rs1, rs2: 寄存器rs1和rs2按位与，结果存储在rd。
OR rd, rs1, rs2: 寄存器rs1和rs2按位或，结果存储在rd。
XOR rd, rs1, rs2: 寄存器rs1和rs2按位异或，结果存储在rd。
SLL rd, rs1, rs2: 寄存器rs1左移rs2位（逻辑左移），结果存储在rd。
SLT rd, rs1, rs2: 如果rs1小于rs2（有符号比较），则rd设置为1，否则设置为0。
SLTU rd, rs1, rs2: 如果rs1小于rs2（无符号比较），则rd设置为1，否则设置为0。
SRL rd, rs1, rs2: 寄存器rs1右移rs2位（逻辑右移），结果存储在rd。
SRA rd, rs1, rs2: 寄存器rs1右移rs2位（算术右移），结果存储在rd。


### I型指令
I型指令包括立即数的运算和load指令

| `31-25`       | `24-20`              | `19-15` | `14-12`    | `11-7` | `6-0`      |  I-Type      |
| ------------- | -------------------- |-------- | ---------- | ------ | ---------- | ------------ |
| **imm[11:5]** | **imm[4:0] / shamt** | **rs1** | **funct3** | **rd** | **opcode** | 指令名称      |
| `imm[11:5]`   |  imm[4:0]            | rs1     | `000`      | rd     | `0010011`  | I_addi       |
| `imm[11:5]`   |  imm[4:0]            | rs1     | `010`      | rd     | `0010011`  | I_slti       |
| `imm[11:5]`   |  imm[4:0]            | rs1     | `011`      | rd     | `0010011`  | I_sltiu      |
| `imm[11:5]`   |  imm[4:0]            | rs1     | `100`      | rd     | `0010011`  | I_xori       |
| `imm[11:5]`   |  imm[4:0]            | rs1     | `110`      | rd     | `0010011`  | I_ori        |
| `imm[11:5]`   |  imm[4:0]            | rs1     | `111`      | rd     | `0010011`  | I_andi       |
| `0000000`     |  shamt               | rs1     | `001`      | rd     | `0010011`  | I_slli       |
| `0000000`     |  shamt               | rs1     | `101`      | rd     | `0010011`  | I_srli       |
| `0100000`     |  shamt               | rs1     | `101`      | rd     | `0010011`  | I_srai       |

ADDI rd, rs1, imm: 将寄存器rs1中的值加上立即数imm，结果存储在rd。立即数imm是12位，其中最高位是符号位。如果imm[11]为1，则需要进行符号扩展，将imm扩展到32位。
ANDI rd, rs1, imm: 寄存器rs1和立即数imm按位与，结果存储在rd。imm也是12位，并遵循同样的符号扩展规则。
ORI rd, rs1, imm: 寄存器rs1和立即数imm按位或，结果存储在rd。立即数imm同样为12位，且根据最高位决定是否进行符号扩展。
XORI rd, rs1, imm: 寄存器rs1和立即数imm按位异或，结果存储在rd。立即数imm的处理方式相同。
SLLI rd, rs1, shamt: 寄存器rs1左移shamt位（逻辑左移），结果存储在rd。shamt是立即数但仅使用低5位（对于RV32I）。
SLTI rd, rs1, imm: 如果rs1小于立即数imm（有符号比较），则rd设置为1，否则设置为0。imm为12位并可能需要符号扩展。
SLTIU rd, rs1, imm: 如果rs1小于立即数imm（无符号比较），则rd设置为1，否则设置为0。imm的处理方式同上。
SRLI/SRAI rd, rs1, shamt: 寄存器rs1右移shamt位（逻辑/算术右移），结果存储在rd。shamt是立即数但仅使用低5位（对于RV32I）。SRAI会考虑符号位进行扩展，而SRLI不会。



| `31-20`       | `19-15` | `14-12`    | `11-7` | `6-0`      |  I-Type      |
| ------------- | ------- | ---------- | ------ | ---------- | ------------ |
| **imm[11:0]** | **rs1** | **funct3** | **rd** | **opcode** | **指令名称**  |
| `imm[11:0]`   | rs1     | `000`      | rd     | `0000011`  | I_lb         |
| `imm[11:0]`   | rs1     | `001`      | rd     | `0000011`  | I_lh         |
| `imm[11:0]`   | rs1     | `010`      | rd     | `0000011`  | I_lw         |
| `imm[11:0]`   | rs1     | `100`      | rd     | `0000011`  | I_lbu        |
| `imm[11:0]`   | rs1     | `101`      | rd     | `0000011`  | I_lhu        |

LB rd, offset(rs1): 从内存地址 rs1 + offset 加载一个有符号字节（8 位），结果存储在 rd 中。
LH rd, offset(rs1): 从内存地址 rs1 + offset 加载一个有符号半字（16 位），结果存储在 rd 中。
LW rd, offset(rs1): 从内存地址 rs1 + offset 加载一个字（32 位），结果存储在 rd 中。
LBU rd, offset(rs1): 从内存地址 rs1 + offset 加载一个无符号字节（8 位），结果存储在 rd 中。
LHU rd, offset(rs1): 从内存地址 rs1 + offset 加载一个无符号半字（16 位），结果存储在 rd 中。


### S型指令
S型指令包括store指令

| `31-25`       | `24-20` | `19-15` | `14-12`    | `11-7`       | `6-0`      |  S-Type      |
| ------------- | ------- | ------- | ---------- | ------------ | ---------- | ------------ |
| **imm[11:5]** | **rs2** | **rs1** | **funct3** | **imm[4:0]** | **opcode** | **指令名称**  |
| `imm[11:5]`   | rs2     | rs1     | `000`      | `imm[4:0]`   | `0100011`  | S_sb         |
| `imm[11:5]`   | rs2     | rs1     | `001`      | `imm[4:0]`   | `0100011`  | S_sh         |
| `imm[11:5]`   | rs2     | rs1     | `010`      | `imm[4:0]`   | `0100011`  | S_sw         |

SB rs2, offset(rs1): 将寄存器 rs2 中的最低一个字节（8 位）写入内存地址 rs1 + offset。
SH rs2, offset(rs1): 将寄存器 rs2 中的最低两个字节（16 位）写入内存地址 rs1 + offset。
SW rs2, offset(rs1): 将寄存器 rs2 中的一个字（32 位）写入内存地址 rs1 + offset。



### B型指令
B型指令包括条件跳转指令
| `31-25`           | `24-20` | `19-15` | `14-12`    | `11-7`           | `6-0`      |  B-Type      |
| ----------------- | ------- | ------- | ---------- | ---------------- |  --------- | ------------ |
| **imm[12\|10:5]** | **rs2** | **rs1** | **funct3** | **imm[4:1\|11]** | **opcode** | **指令名称**  |
| `imm[12\|10:5]`   | rs2     | rs1     | `000`      | `imm[4:1\|11]`   | `1100011`  | B_beq        |
| `imm[12\|10:5]`   | rs2     | rs1     | `001`      | `imm[4:1\|11]`   | `1100011`  | B_bne        |
| `imm[12\|10:5]`   | rs2     | rs1     | `100`      | `imm[4:1\|11]`   | `1100011`  | B_blt        |
| `imm[12\|10:5]`   | rs2     | rs1     | `101`      | `imm[4:1\|11]`   | `1100011`  | B_bge        |
| `imm[12\|10:5]`   | rs2     | rs1     | `110`      | `imm[4:1\|11]`   | `1100011`  | B_bltu       |
| `imm[12\|10:5]`   | rs2     | rs1     | `111`      | `imm[4:1\|11]`   | `1100011`  | B_bgeu       |

BEQ rs1, rs2, offset: 如果rs1等于rs2，则跳转到相对于当前指令的offset位置。offset是一个12位立即数，通过将其某些位复制来扩展至32位以形成完整的偏移量。
BNE rs1, rs2, offset: 类似于BEQ，但如果rs1不等于rs2时跳转。
BLT rs1, rs2, offset: 如果rs1小于rs2（有符号比较），则跳转。
BGE rs1, rs2, offset: 如果rs1大于等于rs2（有符号比较），则跳转。
BLTU rs1, rs2, offset: 如果rs1小于rs2（无符号比较），则跳转。
BGEU rs1, rs2, offset: 如果rs1大于等于rs2（无符号比较），则跳转。


### U型指令
|`31-12`         | `11-7` | `6-0`      | U-type       |
| -------------- | ------ | ---------- | ------------ |
| **imm[31:12]** | **rd** | **opcode** | **指令名称**  |
| `imm[31:12]`   | rd     | `0110111`  | U_lui        |
| `imm[31:12]`   | rd     | `0010111`  | U_auipc      |

LUI rd, imm: 将 20 位的立即数 imm 加载到寄存器 rd 的高 20 位，低 12 位填充为 0。
AUIPC rd, imm: 将当前 PC 值与 20 位的高位立即数 imm 左移 12 位相加，结果存储在 rd 中。

### J型指令

#### J-type 指令：
| `31-12`                      | `11-7` | `6-0`      | **J-type**  |
| ---------------------------- | ------ | ---------- | ----------- |
| **imm[20\|10:1\|11\|19:12]** | **rd** | **opcode** | **指令名称** |
| `imm[20\|10:1\|11\|19:12]`   | rd     | `1101111`  | J_jal       |

#### I-type 指令：
| `31-20`       | `19-15` |    `14-12` | `11-7` | `6-0`      | **I-type**  |
| ------------- | ------- | ---------- | ------ | ---------- | ----------- |
| **imm[11:0]** | **rs1** | **funct3** | **rd** | **opcode** | **指令名称** |
| `imm[11:0]`   | rs1     | `000`      | rd     | `1100111`  | I_jalr      |

JAL rd, offset: 跳转到offset指定的位置，并将返回地址（下一条指令的地址）保存到rd。offset是一个20位立即数，通过特定模式扩展至32位。
JALR rd, rs1, imm: 跳转到rs1加上立即数imm指定的位置，并将返回地址保存到rd。imm是一个12位立即数，可能需要符号扩展。


### RV32M 扩展指令集
1. MUL（funct3=0x0,funct7=0x1）
语法：mul rd, rs1, rs2，作用是将rs1与rs2相乘，结果的低32位写入rd寄存器。
2. MULH（func3=0x1,func7=0x1）
语法：mulh rd, rs1, rs2，作用是将rs1与rs2相乘，结果的高32位写入rd寄存器。
3. MULHSU
语法：mulhsu rd, rs1, rs2，作用是将rs1与rs2相乘，其中rs1为有符号数，rs2为无符号数，结果的高32位写入rd寄存器。
4. MULHU
语法：mulhu rd, rs1, rs2，作用是将rs1与rs2相乘，其中rs1、rs2均为无符号数，结果的高32位写入rd寄存器。
5. DIV
语法：div rd, rs1, rs2，作用是将rs1与rs2相除，结果的商写入rd寄存器。
6. DIVU
语法：divu rd, rs1, rs2，作用是将rs1与rs2相除，其中rs1、rs2均为无符号数，结果的商写入rd寄存器。
7. REM
语法：rem rd, rs1, rs2，作用是将rs1与rs2相除，结果的余数写入rd寄存器。
8. REMU
语法：remu rd, rs1, rs2，作用是将rs1与rs2相除，其中rs1、rs2均为无符号数，结果的余数写入rd寄存器。